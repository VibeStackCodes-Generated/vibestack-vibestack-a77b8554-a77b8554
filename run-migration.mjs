
import { PGlite } from '@electric-sql/pglite';

const db = new PGlite();
try {
  await db.exec("\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'authenticated') THEN CREATE ROLE authenticated; END IF; END $$;\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'anon') THEN CREATE ROLE anon; END IF; END $$;\nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'service_role') THEN CREATE ROLE service_role; END IF; END $$;\nCREATE SCHEMA IF NOT EXISTS auth;\nCREATE TABLE IF NOT EXISTS auth.users (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  email text,\n  role text DEFAULT 'authenticated'\n);\nCREATE OR REPLACE FUNCTION auth.uid() RETURNS uuid LANGUAGE sql STABLE AS $$ SELECT gen_random_uuid() $$;\nCREATE OR REPLACE FUNCTION auth.role() RETURNS text LANGUAGE sql STABLE AS $$ SELECT 'authenticated'::text $$;\nCREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE sql STABLE AS $$ SELECT '{}'::jsonb $$;\n");
  await db.exec("CREATE OR REPLACE FUNCTION update_updated_at()\nRETURNS TRIGGER\nLANGUAGE plpgsql\nSECURITY INVOKER\nSET search_path = ''\nAS $$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$$;\n\nCREATE TABLE IF NOT EXISTS profiles (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,\n  display_name TEXT,\n  avatar_url TEXT,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view all profiles\" ON profiles FOR SELECT TO authenticated USING (true);\n\nCREATE POLICY \"Users can update own profile\" ON profiles FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own profile\" ON profiles FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_profiles_user_id ON profiles (user_id);\n\nCREATE TRIGGER trg_profiles_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n\nCREATE TABLE IF NOT EXISTS wards (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  name TEXT NOT NULL,\n  floor TEXT,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE wards ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own wards\" ON wards FOR SELECT TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own wards\" ON wards FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can update own wards\" ON wards FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can delete own wards\" ON wards FOR DELETE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_wards_user_id ON wards (user_id);\n\nCREATE TRIGGER trg_wards_updated_at BEFORE UPDATE ON wards FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n\nCREATE TABLE IF NOT EXISTS messages (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  content TEXT NOT NULL,\n  channel_id TEXT NOT NULL DEFAULT 'default',\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE messages ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view messages\" ON messages FOR SELECT TO authenticated USING (true);\n\nCREATE POLICY \"Authenticated users can send messages\" ON messages FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_messages_user_id ON messages (user_id);\n\nCREATE TABLE IF NOT EXISTS beds (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE beds ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own beds\" ON beds FOR SELECT TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own beds\" ON beds FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can update own beds\" ON beds FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can delete own beds\" ON beds FOR DELETE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_beds_user_id ON beds (user_id);\n\nCREATE TRIGGER trg_beds_updated_at BEFORE UPDATE ON beds FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n\nCREATE TABLE IF NOT EXISTS assignments (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID NOT NULL,\n  assignment_role TEXT NOT NULL,\n  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n  ward_id UUID NOT NULL REFERENCES wards(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE assignments ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own assignments\" ON assignments FOR SELECT TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own assignments\" ON assignments FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can update own assignments\" ON assignments FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can delete own assignments\" ON assignments FOR DELETE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_assignments_profile_id ON assignments (profile_id);\n\nCREATE INDEX idx_assignments_ward_id ON assignments (ward_id);\n\nCREATE TRIGGER trg_assignments_updated_at BEFORE UPDATE ON assignments FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n\nCREATE TABLE IF NOT EXISTS patients (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  mrn TEXT NOT NULL,\n  full_name TEXT NOT NULL,\n  dob TIMESTAMPTZ,\n  primary_physician_id UUID,\n  ward_id UUID NOT NULL REFERENCES wards(id) ON DELETE CASCADE,\n  bed_id UUID NOT NULL REFERENCES beds(id) ON DELETE CASCADE,\n  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE patients ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own patients\" ON patients FOR SELECT TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own patients\" ON patients FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can update own patients\" ON patients FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can delete own patients\" ON patients FOR DELETE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_patients_ward_id ON patients (ward_id);\n\nCREATE INDEX idx_patients_bed_id ON patients (bed_id);\n\nCREATE INDEX idx_patients_profile_id ON patients (profile_id);\n\nCREATE INDEX idx_patients_user_id ON patients (user_id);\n\nCREATE TRIGGER trg_patients_updated_at BEFORE UPDATE ON patients FOR EACH ROW EXECUTE FUNCTION update_updated_at();\n\nCREATE TABLE IF NOT EXISTS clinical_notes (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  author_id UUID NOT NULL,\n  note TEXT NOT NULL,\n  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,\n  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE clinical_notes ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view own clinical_notes\" ON clinical_notes FOR SELECT TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can insert own clinical_notes\" ON clinical_notes FOR INSERT TO authenticated WITH CHECK ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can update own clinical_notes\" ON clinical_notes FOR UPDATE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE POLICY \"Users can delete own clinical_notes\" ON clinical_notes FOR DELETE TO authenticated USING ((select auth.uid()) = user_id);\n\nCREATE INDEX idx_clinical_notes_patient_id ON clinical_notes (patient_id);\n\nCREATE INDEX idx_clinical_notes_profile_id ON clinical_notes (profile_id);\n\nCREATE INDEX idx_clinical_notes_user_id ON clinical_notes (user_id);\n\nCREATE TRIGGER trg_clinical_notes_updated_at BEFORE UPDATE ON clinical_notes FOR EACH ROW EXECUTE FUNCTION update_updated_at();");
  console.log('MIGRATION_OK');
} catch (e) {
  console.error('MIGRATION_ERROR:', e.message);
  process.exit(1);
} finally {
  await db.close();
}
